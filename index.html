<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>G116-D2</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<style>
body { background-color: #0a0; color: white; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 20px; }
table { border-collapse: collapse; width: 100%; margin-top: 20px; }
th, td { padding: 8px 12px; border: 1px solid #444; text-align: center; }
.profitable { background-color: #00ff00; color: black; font-weight: bold; }
#log { max-height: 220px; overflow-y: auto; border: 1px solid #444; margin-top: 10px; padding: 10px; background: #111; }
button { padding: 8px 16px; margin: 5px; background: #333; color: white; border: none; border-radius: 4px; cursor: pointer; }
button:hover { background: #555; }
.control-group { margin: 10px 0; display: flex; flex-wrap: wrap; align-items: center; gap: 15px; }
.control-group label { display: flex; align-items: center; gap: 6px; }
.profit-display { font-size: 1.1em; font-weight: bold; margin: 10px 0; padding: 8px; background: #333; border-radius: 4px; }
.subtle { opacity: .9; font-weight: 600; }
input[type="number"] { width: 90px; }
.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
</style>
</head>
<body>
<h1>G116-D2</h1>
<p><strong>Wallet:</strong> <span id="wallet" class="mono">-</span></p>
<p><strong>Wallet USDC Balance:</strong> <span id="walletBalance" class="mono">-</span></p>
<p><strong>Contract USDC Balance:</strong> <span id="contractBalance" class="mono">-</span></p>
<div class="profit-display">
<strong>Accumulated Profit:</strong> <span id="accumulatedProfit" class="mono">0.00</span> USDC
</div>

<div class="control-group">
<button id="connectWallet">Connect Wallet</button>
<button id="scanNow">Scan Now</button>
<button id="withdrawUSDC">Withdraw USDC</button>
<button id="startScan">Start</button>
<button id="stopScan">Stop</button>
<button id="pauseScan">Pause</button>
</div>

<div class="control-group">
<label><input type="checkbox" id="autoTradeToggle"> Auto Trade</label>
<label><input type="checkbox" id="backgroundTradeToggle"> Auto Trade in Background</label>
<label><input type="checkbox" id="accumulateToggle"> Let profits accumulate in contract</label>
<label><input type="checkbox" id="positiveBalanceToggle" checked> Only trade if contract balance increases</label>
</div>

<div class="control-group">
<label>Min Profit %: <input type="number" id="minProfitPct" value="0.2" step="0.1" min="0.1">%</label>
<label>Trade Amount: <input type="number" id="tradeAmount" value="10" min="1"> USDC</label>
<label>Batch Trades (1-100): <input type="number" id="batchCount" value="1" min="1" max="100" step="1"></label>
<label>Slippage %: <input type="number" id="slippagePct" value="0" step="0.1" min="0">%</label>
</div>

<div class="control-group">
<label>
Scan interval:
<input type="range" id="scanIntervalSec" min="0" max="100" value="30" step="1">
<span id="scanIntervalLabel" class="subtle mono">30s</span>
</label>
<label title="If ON: we still show raw 🚨 opportunities, but add ✅ when callStatic also shows profit. Auto-Trade will require ✅.">
<input type="checkbox" id="callStaticToggle" checked>
Require callStatic confirmation for Auto-Trade <span class="mono">✅</span>
</label>
</div>

<table id="resultTable">
<thead>
<tr>
<th>Token</th>
<th>Buy Router</th>
<th>Sell Router</th>
<th>Buy Price (USDC)</th>
<th>Sell Price (USDC)</th>
<th>Profit (USDC)</th>
<th>Profit %</th>
<th>Status</th>
<th>Action</th>
</tr>
</thead>
<tbody id="results"></tbody>
</table>

<div id="log"></div>

<div class="control-group">
<button id="exportCSV">Export Successful Transactions</button>
</div>

<script>
// -------------------------
// CONFIG
// -------------------------
let transactionHistory = [];
const contractAddress = "0x34B23677184efda6Bf2282EC141dd1Dd8bbA1761";
const contractABI = [
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "buyRouter",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "sellRouter",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			}
		],
		"name": "executeArbitrage",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "asset",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "premium",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "bytes",
				"name": "params",
				"type": "bytes"
			}
		],
		"name": "executeOperation",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_aavePool",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "_usdc",
				"type": "address"
			}
		],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			}
		],
		"name": "withdrawProfit",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "AAVE_POOL",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "USDC",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
];

const tokens = {
AAVE:{address:"0xd6df932a45c0f255f85145f286ea0b292b21c90b",decimals:18},
APE:{address:"0x4d224452801aced8b2f0aebe155379bb5d594381",decimals:18},
AXLUSDC:{address:"0x2a2b6055a5c6945f4fe0e814f5d4a13b5a681159",decimals:6},
      BETA:{address:"0x0afaabcad8815b32bf2b64e0dc5e1df2f1454cde",decimals:18},
      BONE:{address:"0xad37e3433ebde20e5fbf531e6c7da1655c60bb8e",decimals:18},
      CRV:{address:"0x172370d5cd63279efa6d502dab29171933a610af",decimals:18},
      DAI:{address:"0x8f3cf7ad23cd3cadbd9735aff958023239c6a063",decimals:18},
      DPI:{address:"0x1494ca1f11d487c2bbe4543e90080aeba4ba3c2b",decimals:18},
      FND:{address:"0x292c4eefdda27062049d44d4730d5fe774b5f4c7",decimals:18},
      FREE:{address:"0xe1ae4d4a3a2200ae5ac06e50bca0dd7e52a19238",decimals:18},
      KLIMA:{address:"0x4e78011ce80ee02d2c3e649fb657e45898257815",decimals:9},
      LDO:{address:"0xbb0bb78beeea5cf201b8f2651f48830e64ce45a4",decimals:18},
      LINK:{address:"0x53e0bca35ec356bd5dddfebbd1fc0fd03fabad39",decimals:18},
      MATICX:{address:"0xa3fa99a148fa48d14ed51d610c367c61876997f1",decimals:18},
      OS:{address:"0xd3a691c852cdb01e281545a27064741f0b7f6825",decimals:18},
      QUICK:{address:"0x831753dd7087cac61ab5644b308642cc1c33dc13",decimals:18},
      RNDR:{address:"0x6c3c7886b43d005db8c28a09e8038b87e36cf26c",decimals:18},
      SHIB:{address:"0x6f8a06447ff6fcf75a5fcdb3f8c4bab2da4fc0d0",decimals:18},
      SHIKIGON:{address:"0x3f0fb6e42d160a8def49fe68b8ef4d8a5b7ab119",decimals:18},
      SURE:{address:"0xf638a9594c0c780d6c8bc40fa33efb0ceabf5d57",decimals:18},
      THE7:{address:"0x045f7ffdcc8334e78316a2c1164efb2e5f3815d5",decimals:18},
      TRADE:{address:"0x82362ec182db3cf7829014bc61e9be8a2e82868a",decimals:18},
      UNI:{address:"0x1f9840a85d5af5bf1d1762f925bdaddc4201f984",decimals:18},
      UNI2:{address:"0xb33eaad8d922b1083446dc23f610c2567fb5180f",decimals:18}, // separate key
      USDC:{address:"0x2791bca1f2de4661ed88a30c99a7a9449aa84174",decimals:6},
      USDT:{address:"0xc2132d05d31c914a87c6611c10748aeb04b58e8f",decimals:6},
      WBTC:{address:"0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6",decimals:8},
      WETH:{address:"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",decimals:18},
USDC:{address:"0x2791bca1f2de4661ed88a30c99a7a9449aa84174",decimals:6}
// add all other tokens exactly as before...
};

const routers = {
QuickSwap: "0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff",
SushiSwap: "0x1b02da8cb0d097eb8d57a175b88c7d8b47997506",
// include all other routers as before
};

// -------------------------
// STATE
// -------------------------
let provider, signer, contract, walletAddress;
let isScanning = false;
let scanInterval;
let accumulatedProfit = 0;

// -------------------------
// INIT
// -------------------------
window.addEventListener('load', function() {
document.getElementById('connectWallet').addEventListener('click', connectWallet);
document.getElementById('scanNow').addEventListener('click', manualScan);
document.getElementById('withdrawUSDC').addEventListener('click', withdrawUSDC);
document.getElementById('scanIntervalSec').addEventListener('input', onScanIntervalChange);
document.getElementById('startScan').addEventListener('click', () => { startAutoScan(); log("Auto scan started"); });
document.getElementById('stopScan').addEventListener('click', () => { clearInterval(scanInterval); log("Auto scan stopped"); });
document.getElementById('pauseScan').addEventListener('click', () => { isScanning = !isScanning; log(isScanning ? "Auto scan paused" : "Auto scan resumed"); });
restoreTransactionHistory();
onScanIntervalChange();
});

// -------------------------
// WALLET / BALANCES
// -------------------------
async function connectWallet() {
try {
if (!window.ethereum) throw new Error("MetaMask not found");
provider = new ethers.providers.Web3Provider(window.ethereum);
await provider.send("eth_requestAccounts", []);
signer = provider.getSigner();
walletAddress = await signer.getAddress();
document.getElementById("wallet").textContent = walletAddress;
contract = new ethers.Contract(contractAddress, contractABI, signer);
await updateBalances();
startAutoScan();
log("Wallet connected successfully");
} catch (error) { log(`⚠️ Wallet connection failed: ${error.message}`); }
}

async function updateBalances() {
try {
if (!provider || !walletAddress) return;
const usdcAddr = tokens.USDC.address;
const usdc = new ethers.Contract(usdcAddr, ["function balanceOf(address) view returns (uint256)", "function decimals() view returns (uint8)"], provider);
const decimals = await usdc.decimals();
const [balance, contractBal] = await Promise.all([usdc.balanceOf(walletAddress), usdc.balanceOf(contractAddress)]);
document.getElementById("walletBalance").textContent = Number(ethers.utils.formatUnits(balance, decimals)).toFixed(6);
document.getElementById("contractBalance").textContent = Number(ethers.utils.formatUnits(contractBal, decimals)).toFixed(6);
} catch (error) { log(`⚠️ Balance update failed: ${error.message}`); }
}

// -------------------------
// GET AMOUNT OUT (EXACTLY AS BEFORE)
// -------------------------
async function getAmountOut(router, token, amountIn, useCallStatic = false) {
try {
const routerContract = new ethers.Contract(
router,
["function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory)"],
provider
);
const path = [tokens.USDC.address, token];

let amountsOut;
if (useCallStatic && routerContract.callStatic && typeof routerContract.callStatic.getAmountsOut === 'function') {
amountsOut = await routerContract.callStatic.getAmountsOut(amountIn, path);
} else {
amountsOut = await routerContract.getAmountsOut(amountIn, path);
}

const tokenContract = new ethers.Contract(token, ["function decimals() view returns (uint8)"], provider);
const decimals = await tokenContract.decimals();
return Number(ethers.utils.formatUnits(amountsOut[1], decimals));
} catch (error) { throw new Error(`GetAmountOut failed: ${error.message}`); }
}

// -------------------------
// SCAN / ARBITRAGE
// -------------------------
async function manualScan() { if (isScanning) return; await scanAndArbitrage(); }

function currentIntervalMs() {
const sec = parseInt(document.getElementById('scanIntervalSec').value || "30", 10);
return Math.max(0, Math.min(100, sec)) * 1000;
}

function onScanIntervalChange() {
const sec = parseInt(document.getElementById('scanIntervalSec').value || "30", 10);
document.getElementById('scanIntervalLabel').textContent = `${sec}s`;
if (scanInterval) startAutoScan();
}

function startAutoScan() {
if (scanInterval) clearInterval(scanInterval);
const iv = currentIntervalMs();
scanInterval = setInterval(() => { if (!isScanning) scanAndArbitrage(); }, iv || 250);
log(`Auto scan interval set to ${iv/1000}s`);
}

async function scanAndArbitrage() {
if (!walletAddress) { log("Connect wallet first"); return; }
isScanning = true;
document.getElementById("results").innerHTML = "";
log("Starting arbitrage scan...");

try {
const minProfitPct = parseFloat(document.getElementById("minProfitPct").value);
const tradeAmount = parseFloat(document.getElementById("tradeAmount").value);
const slippagePct = parseFloat(document.getElementById("slippagePct").value);
const requireStatic = document.getElementById("callStaticToggle").checked;
const amountIn = ethers.utils.parseUnits(tradeAmount.toString(), 6);

for (const [symbol, meta] of Object.entries(tokens)) {
const token = meta.address;
for (const [buyName, buyRouter] of Object.entries(routers)) {
for (const [sellName, sellRouter] of Object.entries(routers)) {
if (buyName === sellName) continue;

try {
const buyOut = await getAmountOut(buyRouter, token, amountIn, false);
const sellOut = await getAmountOut(sellRouter, token, amountIn, false);
const buyPrice = tradeAmount / buyOut;
const sellPrice = tradeAmount / sellOut;
const profitUSDC = sellPrice - buyPrice;
const profitPct = (profitUSDC / buyPrice) * 100;

let profitPctStatic = NaN;
if (requireStatic) {
const buyOutStatic = await getAmountOut(buyRouter, token, amountIn, true);
const sellOutStatic = await getAmountOut(sellRouter, token, amountIn, true);
profitPctStatic = ((tradeAmount / sellOutStatic - tradeAmount / buyOutStatic) / (tradeAmount / buyOutStatic)) * 100;
}

const slAdj = (1 - slippagePct/100);
const slippageAdjustedProfitPct = profitPct * slAdj;
const slippageAdjustedProfitUSDC = profitUSDC * slAdj;

const row = document.createElement("tr");
if (slippageAdjustedProfitPct > minProfitPct) row.classList.add("profitable");

const statusSymbols = slippageAdjustedProfitPct > minProfitPct ? '🚨' : '❌ Skip';
const actionCell = document.createElement("td");
const tradeBtn = document.createElement("button");
tradeBtn.textContent = "Trade";
tradeBtn.onclick = () => executeTrade(buyRouter, sellRouter, token, amountIn, symbol, slippageAdjustedProfitPct);
actionCell.appendChild(tradeBtn);

row.innerHTML = `<td>${symbol}</td><td>${buyName}</td><td>${sellName}</td><td class="mono">${buyPrice.toFixed(6)}</td><td class="mono">${sellPrice.toFixed(6)}</td><td class="mono">${slippageAdjustedProfitUSDC.toFixed(6)}</td><td class="mono">${slippageAdjustedProfitPct.toFixed(2)}%</td><td>${statusSymbols}</td>`;
row.appendChild(actionCell);
document.getElementById("results").appendChild(row);

if (document.getElementById("autoTradeToggle").checked && (!requireStatic || profitPctStatic > minProfitPct)) {
const backgroundMode = document.getElementById("backgroundTradeToggle").checked;
if (backgroundMode) executeTrade(buyRouter, sellRouter, token, amountIn, symbol, slippageAdjustedProfitPct).catch(e => log(`⚠️ Background trade failed: ${e.message}`));
else await executeTrade(buyRouter, sellRouter, token, amountIn, symbol, slippageAdjustedProfitPct);
}

} catch (e) { log(`⚠️ ${symbol} ${buyName} → ${sellName} failed: ${e.message}`); }
}
}
}

} catch (error) { log(`⚠️ Scan failed: ${error.message}`); }
finally { isScanning = false; await updateBalances(); log("Scan completed"); }
}

// -------------------------
// TRADE / WITHDRAW
// -------------------------
async function executeTrade(buyRouter, sellRouter, token, amountIn, symbol, profitPct) {
try {
const batchCount = Math.min(parseInt(document.getElementById("batchCount").value || "1"), 100);
log(`⚡ Executing arbitrage for ${symbol} (${profitPct.toFixed(2)}%) x${batchCount}...`);
for (let i = 0; i < batchCount; i++) {
const contractUSDCBefore = await getContractUSDCBalance();
const tx = await contract.executeArbitrage(buyRouter, sellRouter, token, amountIn, { gasLimit: 1000000 });
log(`Transaction ${i+1}/${batchCount} sent: ${tx.hash}`);
await tx.wait();
const contractUSDCAfter = await getContractUSDCBalance();
const profit = contractUSDCAfter - contractUSDCBefore;

if (!document.getElementById("positiveBalanceToggle").checked || profit > 0) {
if (profit > 0) { accumulatedProfit += profit; document.getElementById("accumulatedProfit").textContent = accumulatedProfit.toFixed(2); }
}

if (!document.getElementById("accumulateToggle").checked) { await withdrawUSDC(); }
await updateBalances();
}
} catch (error) { log(`⚠️ Arbitrage failed for ${symbol}: ${error.message}`); }
}

async function withdrawUSDC() {
try {
log("Withdrawing USDC from contract...");
const tx = await contract.withdrawProfit(tokens.USDC.address);
await tx.wait();
log("✅ USDC withdrawn successfully");
await updateBalances();
} catch (error) { log(`⚠️ Withdrawal failed: ${error.message}`); }
}

async function getContractUSDCBalance() {
const usdc = new ethers.Contract(tokens.USDC.address, ["function balanceOf(address) view returns (uint256)","function decimals() view returns (uint8)"], provider);
const decimals = await usdc.decimals();
const balance = await usdc.balanceOf(contractAddress);
return Number(ethers.utils.formatUnits(balance, decimals));
}

// -------------------------
// LOG / STORAGE
// -------------------------
function log(message) { const logDiv = document.getElementById("log"); logDiv.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}<br>` + logDiv.innerHTML; }

function restoreTransactionHistory() {
try { const saved = localStorage.getItem("transactionHistory"); if (!saved) return; transactionHistory = JSON.parse(saved); } catch(e){console.error(e);}
}
</script>
</body>
</html>
